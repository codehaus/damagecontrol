h1. Architecture

This object digram describes in coarse detail how some of the core objects relate to each other.
It describes how a build process starts by first checking out, determining if there are any changes,
and then possibly executing a build. The steps are as follows:

1) A checkout is requested.
There are two different situations that will result in a build to be executed. They both start
with the blue objects:

# A build is trigged (step 0). This can be done via the web interface or over XML-RPC. Typical XML-RPC
invocations come from either a trigger in the SCM (if it is installed), or via some other external program 
using the XML-RPC interface.
# The SCMPoller decides it is time to poll a project and see if there are any changes.

2) The CheckoutManager asks the SCM to check out the latest code. This call will return a ChangeSets object
which contains detailed information of what was checked out (and maybe even deleted) since the last checkout.
It then finds most recent timestamp of all the changes in the ChangeSets and saves that timestamp in the project
configuration (to be used in the future).

(For practical reasons, if the checkout is a first-time checkout, the SCM will return the timestamp of the most 
recent checkin rather than all the changesets. This is to avoid having a too big list of changes in the first build
report).

3) A build object is created (which holds the changesets), and the execution of that build is requested within the BuildScheduler.
Special note for SCMPoller: This will only happen if there were changes. If there were no changes as the result of
the checkout, no request will be made with the BuildScheduler.

4) When a BuildExecutor becomes available (there may be several of them, depending on how you have configured DamageControl), 
the scheduled build will be given to it. The BuildExecutor will execute the build, and finally send an event on the hub
when the build is finished (whether it succeeded or not). This event will then be picked up by other components, which may perform
various notification tasks (email, irc, etc.)

h1. Source Control Management (SCM) plugins

This is a guide for people who want to write a new SCM plugin for DamageControl.

h2. Writing the SCM class
DamageControl relies on the RubySCM API for interaction with underlying SCMs. 
(RubySCM is an API that has been factored out of DamageControl's core). 
The first step in adding support for a new SCM is to write a RubySCM class.

To prove compliance with the RubySCM API we have written a test suite that you can use. If your class passes that test suite,
you can be pretty sure your SCM class is good enough for DamageControl, and we'll happily add it to the codebase.

h2. Write a test class that uses RubySCMs test suite

{snippet}

and a skeleton of your SCM class

{snippet}

Try to run the test:

{code}
ruby -Iserver server/rubyscm/MookyTest
{code}

This will probably fail, and it is time to fix the first error - implement the create method.

{code}
def initialize(mooky_dir)
  @mooky_dir = mooky_dir
end

def create(&line_proc)
  cmd(@mooky_dir, "mooky create", &line_proc)
end
{code}

Run the test again. Assuming your code is correct, you should now get a different error, which should lead you to
implement the next method. Just continue like this until all tests are passing :-)

If your SCM's command line interface writes output that needs to be parsed, we recommend you implement the parsing
logic in a spearate class. That will allow you to test the parser without running the command.

h1. RubySCM API

Here is a more detailed description of the required methods in the RubySCM API.

h2. create(&line_proc)
(Local method)
This method should call the mooky command line that will create a new repository. Details about where it should be created
should be passed to the constructor.

h3. Parameters
* &line_proc - A block that should receive lines from the command(s)'s standard output.

h2. import(import_dir, &line_proc) 
(Local method)
This method should call the mooky command line that will recursively import files into the repository.

h3. Parameters
* import_dir - The directory to import.
* &line_proc - A block that should receive lines from the command(s)'s standard output.

h2. checkout(checkout_dir, scm_from_time, scm_to_time, &line_proc)
(Regular method)
This method should call the mooky command line that will check out previously imported sources to a working folder.

h3. Parameters
* checkout_dir - The directory where files should be checked out.
* scm_from_time - The from-time (inclusive) for which we want files checked out. If nil, it means from the start of time.
* scm_to_time - The to-time (inclusive) for which we want files checked out. If nil, it means up to the end of time.
* &line_proc - A block that should receive lines from the command(s)'s standard output.

h3. Return values
* If nothing was checked out (i.e. uptodate), return nil.
* If this is the first checkout, return the UTC timestamp of the last checkin, according to the SCM's clock.
* If this was an update, (i.e. previously checked out, but not uptodate), return a ChangeSets object representing all
  the changes within the period.

h2. commit(checkout_dir, commit_message, &line_proc)
(Local method)
Commits (checks in) all files that have been locally modified.

h3. Parameters
* checkout_dir - The directory where files should be checked out.
* commit_message - The message that should go along with the commit.
* &line_proc - A block that should receive lines from the command(s)'s standard output.

h1. RubySCM optional API

If the SCM supports triggers, you can implement the following methods to allow installation (and uninstallation) of
triggers in the SCM. A trigger is a command that gets executed as the result of a commit (checkin).

h2. install_trigger(trigger_command, trigger_files_checkout_dir, &line_proc)
This method should install the trigger command in such a way that it is executed when a commit to the SCM occurs.

h3. Parameters
* trigger_command - The command to run when the trigger is fired.
* trigger_files_checkout_dir - A working folder that can optionally be used if the trigger installation
  requires it. (The parameter was added because CVS needs it).
* &line_proc - A block that should receive lines from the command(s)'s standard output.

h2. trigger_installed?(trigger_command, trigger_files_checkout_dir, &line_proc)
This method should return true if the trigger_command is installed, otherwise false.

h2. uninstall_trigger(trigger_command, trigger_files_checkout_dir, &line_proc)
This method should install the trigger command in such a way that it no longer executed when a commit to the SCM occurs.
