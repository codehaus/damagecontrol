= RSCM - Ruby Source Control Management

RSCM is a Ruby library for various Source Control Management (SCM) systems. RSCM provides an intuitive API
which is described in AbstractSCM.

= Feature overview

* Generation of RSS feeds.
* Generation of URL links to diffs for several popular SCM web front-ends.
* Generation of URL links to bugs/issues for several popular bug/issue trackers.
* Changeset emulation for SCMs that don't support it natively (like CVS and StarTeam)
* API support for several high level operations such as checkout, get changesets, check for uptodate etc.
* RSCM objects are easily serializable to YAML.

== RSS Server

RSCM can generate RSS feeds for all supported SCMs. The RSS feeds will have one item per changeset.
Each RSS item's description contains the changeset's commit message, optionally with HTML links to
issue/bug tracker issues (if detected in the changeset's commit message). The item's description
will also contain a list of all the modified files, optionally with HTML links to a diff page
in an SCM web front-end.

A daemon-like utility for periodically generating RSS feeds (and writing to a disk) is underway.
It will be customisable with a simple YAML file. It will also come with its ownb embedded web server
(WEBrick) that can be used to serve the RSS, as well as configure the settings for the feeds.

== Supported SCMs

* CVS
* P4 (in progress)
* StarTeam (in progress)
* Subversion

== Supported Issue trackers

RSCM can recognise bug/issue numbers (in commit messages) fom a number of popular issue 
tracking systems. It can also convert a simple textual SCM commit message to include html
links that can be displayed on web pages, emails and other systems. The built-in RSS generator
uses this. Currently supported trackers are:

* Bugzilla
* JIRA
* RubyForge
* Scarab
* SourceForge

Planned:

* Trac

== SCM web front-ends

RSCM can generate html links to individual diff pages in SCM web frontends. These links can be 
displayed on web pages, emails and other systems. The built-in RSS generator uses this.  
Currently supported web front-ends are:

* Fisheye
* ViewCVS

Planned:

* Trac
* Chora

This way links to diffs can be easily created.

== API usage

Here is an example of how to use RSCM to get a list of changes with Subversion:

  require 'rscm'
  
  scm = RSCM::SVN.new
  scm.svnurl = "svn://some.server/some/path/trunk"
  scm.svnpath = "trunk"

  scm.checkout("mycheckout")
  changesets = scm.changesets("mycheckout", Time.utc(2004, 11, 10, 12, 34, 22))
  changesets.each do |changeset|
    puts changeset
  end

= Implementing support for a new SCM

Let's write an RSCM implementation for the imaginary SCM called Mooky.
Start by writing a test:

<<< test/rscm/mooky/mooky_test.rb

By including GenericSCMTests your test will automatically include the
acceptance test suite for RSCM. As you will see later, this will be of great
help when developing the Mooky class.

Let's start implementing the Mooky class too:

<<< Rakefile
<<< lib/rscm/mooky/mooky.rb

Try running this test:

  rake test TEST_FILES=**/mooky_test.rb
  
Whoops - we got some failures! Let'see if we can get the test_basic method
to get a little further before it fails. It failed because our checkout
method returned nothing (nil).

The Mooky SCM happens to have a command line utility to perform a checkout.
From the command line a checkout with mooky would be done like this:

  cd somewhere
  mooky checkout --repo mooky://some/where/else

This will print the following to standard out:

  checkout build.xml
  checkout project.xml
  checkout src/java/com/thoughtworks/damagecontrolled/Thingy.java
  checkout src/test/com/thoughtworks/damagecontrolled/ThingyTestCase.java
  
What we need to do is to execute these commands from Ruby. We also need to 
parse the output from the mooky command to determine the files that were checked out,
so that we can return an array with the right information.

NOTE: If the SCM already has a 3rd party Ruby API (like Perforce), we would probably
want to use that instead of the command line API.

NOTE: If the SCM doesn't have a command line utility or a 3rd party Ruby API, but instead
provides libraries (perhaps in C), then you should consider writing a Ruby C extension
instead.

= Implementation notes

* SCM classes should have a no-arg constructor and be serialisable with YAML
* SCM classes should be inexpensive to instantiate (should not access SCM in constructor)

= Web interface