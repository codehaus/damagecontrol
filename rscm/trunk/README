= RSCM - Ruby Source Control Management

RSCM is a Ruby library for various Source Control Management (SCM) systems. RSCM provides an intuitive API
which is described in AbstractSCM.

= Feature overview

* API support for several high level operations such as checkout, get changesets, check for uptodate etc.
* Built-in admin server based on Rails (http://www.rubyonrails.org/)
* Generation of RSS feeds.
* Generation of URL links to diffs for several popular SCM web front-ends.
* Generation of URL links to bugs/issues for several popular bug/issue trackers.
* Changeset emulation for SCMs that don't support it natively (like CVS and StarTeam)
* RSCM objects are easily serializable to YAML.
* Uses UTC times according to the SCM server's clock, not the machine running RSCM.

=== Wish:

Implement coloured diffs simliar to CVSSpam/SVN::Notify so that all supported SCMs 
(not only CVS) can benefit from its awesome coloured diff capabilities. This would 
provide a very nice alternative to SCM web front-ends.

Implement import/export functionality to allow migrating from one SCM to another while
keeping the history. Great for migration from archaic SCMs!

Bridging: Your project uses a different SCM type than the one *you* like to use. You set up a local
repo of your preferred SCM type, and RSCM automatically mediates changesets back and forth between the
central SCM and your local one.

== RSCM Server

RSCM ships with a web app based on Rails (which you have to install separately). To launch:

  ruby script/server
  
You also need to launch (in a separate console) the RSCM daemon process:

  ruby -Ilib lib/rscm/server.rb
  
The daemon process is the core of RSCM, that performs SCM access. The web app communicates with this process
over Drb. The reason why two processes are needed is due to the fact that Dir.chdir may happen in various threads,
which will confuse the webapp. We tried with forking, but this is not supported on Windows.

Once the two servers are started, you can access the web app on:

  http://localhost:4712/

== RSS Support

The RSCM daemon can generate RSS feeds for all supported SCMs. The RSS feeds will have one item per changeset.
Each RSS item's description contains the changeset's commit message, optionally with HTML links to
issue/bug tracker issues (if detected in the changeset's commit message). The item's description
will also contain a list of all the modified files, optionally with HTML links to a diff page
in an SCM web front-end.

== Supported SCMs

* CVS - http://www.cvshome.org/
* StarTeam - http://www.borland.com/starteam/
* Subversion - http://subversion.tigris.org/

In progress:

* Darcs - http://www.abridgegame.org/darcs/
* Monotone - http://www.venge.net/monotone/
* Perforce - http://www.perforce.com/

Planned:

Loads! How to add support for a new one is described further down in this file.

== Supported Issue trackers

RSCM can recognise bug/issue numbers (in commit messages) fom a number of popular issue 
tracking systems. It can also convert a simple textual SCM commit message to include html
links that can be displayed on web pages, emails and other systems. The built-in RSS generator
uses this. Currently supported trackers are:

* Bugzilla - http://www.bugzilla.org/
* JIRA - http://www.atlassian.com/software/jira/
* RubyForge - http://rubyforge.org/
* Scarab - http://scarab.tigris.org/
* SourceForge - http://sourceforge.net/

Planned:

* Trac - http://www.edgewall.com/trac/
* RT - http://fsck.com/projects/rt/

== SCM web front-ends

RSCM can generate html links to individual diff pages in SCM web frontends. These links can be 
displayed on web pages, emails and other systems. The built-in RSS generator uses this.  
Currently supported web front-ends are:

* Fisheye - http://www.cenqua.com/fisheye/
* ViewCVS - http://viewcvs.sourceforge.net/

Planned:

* Trac - http://www.edgewall.com/trac/
* Chora - http://horde.org/chora/

This way links to diffs can be easily created.

== API usage

Here is an example of how to use RSCM to get a list of changes with Subversion:

  require 'rscm'
  
  scm = RSCM::SVN.new
  scm.svnurl = "svn://some.server/some/path/trunk"
  scm.svnpath = "trunk"

  scm.checkout("mycheckout")
  changesets = scm.changesets("mycheckout", Time.utc(2004, 11, 10, 12, 34, 22))
  changesets.each do |changeset|
    puts changeset
  end

= Implementing support for a new SCM

We'd be happy to receive contributions for more SCMs. You can always
file a JIRA issue and hope for someone to implement it for you, or
you can do it yourself. The rest of this file should get you started.

N.B. IF YOU START IMPLEMENTING A NEW RSCM PLUGIN, PLEASE SUBMIT YOUR CODE
TO JIRA AT AN EARLY STAGE (BEFORE IT'S COMPLETE). THIS WAY IT'S EASIER
FOR EXISTING DEVELOPERS TO PROVIDE TIPS AND HELP UNDERWAY.

Let's write an RSCM implementation for the imaginary SCM called Mooky.

== Writing the API

Start by writing a test:

<<< test/rscm/mooky/mooky_test.rb

By including GenericSCMTests your test will automatically include the
acceptance test suite for RSCM. As you will see later, this will be of great
help when developing the Mooky class.

Let's start implementing the Mooky class too. Take a look at.

  lib/rscm/mooky/mooky.rb

Try running Mooky's test:

  rake test TEST=test/rscm/mooky/mooky_test.rb
  
Whoops - we got some failures! It failed because our checkout method returned 
nothing (nil). Let'see if we can get the a little further by implementing this
method.

The Mooky SCM happens to have a command line utility to perform a checkout.
From the command line a checkout with mooky would be done like this:

  cd somewhere
  mooky checkout --repo mooky://some/where/else

Running this command will print the following to standard out:

  checkout build.xml
  checkout project.xml
  checkout src/java/com/thoughtworks/damagecontrolled/Thingy.java
  checkout src/test/com/thoughtworks/damagecontrolled/ThingyTestCase.java
  
What we need to do is to execute these commands from Ruby. We also need to 
parse the output from the mooky command to determine the files that were checked out,
so that we can return an array with the file names of the checked out files (the method 
should also yield each file name as the execution proceeds).

Once your checkout command works okay, the test will get you a little further. Just keep
on going until all tests pass.

NOTE: If the SCM doesn't have a command line utility or a 3rd party Ruby API, but instead
provides libraries (perhaps in C), then you should consider writing a Ruby C extension
instead.

If the SCM has a Java interface, you can take the same approach as for StarTeam. There are
Java classes for Changesets that allow easy interaction between Ruby and Java over YAML. 
You can reuse these classes for other Java based SCMs (if there are any).

== Writing the web interface

Start by creating +app/views/project/_mooky.rhtml+. 

Create a table with 2 columns and a row for each +attr_accessor+ in the Mooky class, preferrably
with some explanatory text for the users so they know how to fill it in.

You also need a javascript section at the top
with a function called +mooky_init()+. This will be called when the page is loaded. If you don't
have plans to do anything fancy here, just leave it blank.

That's all!

== Wiring it all up

Just edit +lib/rscm.rb+ and +require+ your new scm class. Now you should see it coming up
on the Source Control tab in the web interface.

= Implementation notes

* SCM classes should have a no-arg constructor and be serialisable with YAML
* SCM classes should be inexpensive to instantiate (should not access SCM in constructor)

= Building RSCM
This section is for developers who are new to ruby development and do not already know how to build and install Ruby gems.

You need to install rubygems from http://rubyforge.org/projects/rubygems
Afterwards you need to install rake and rails

  gem install rake
  gem install rails

Now change to the RSCM root directory and type

  rake

This will create a gem for RSCM. To install this gem, you have to change to the pgk directory and type

  sudo gem install rscm
  
Now you can use RSCM in other Ruby apps.
