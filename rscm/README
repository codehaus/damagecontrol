= RSCM - Ruby Source Control Management

RSCM is to SCM what ODBC/JDBC is to databases - a common API to access a wide variety of SCMs. The features are roughly:

* Check out a working copy (with possibility to specify branch/date/label)
* Get changesets (changesets are emulated for non-transactional SCMs like CVS and StarTeam)
* Get diffs
* Add and commit files
* Manipluate triggers

== Supported SCMs

* CVS - http://www.cvshome.org/
* StarTeam - http://www.borland.com/starteam/
* Subversion - http://subversion.tigris.org/

In progress:

* Darcs - http://www.abridgegame.org/darcs/
* Monotone - http://www.venge.net/monotone/
* Perforce - http://www.perforce.com/

Planned:

Loads! How to add support for a new one is described further down in this file.

== Related projects

* DamageControl - http://damagecontrol.codehaus.org/. DamageControl adds a web interface to RSCM and tons of other features for continuous integration.

== API usage

Here is an example of how to use RSCM to get a list of changes with Subversion:

  require 'rscm'
  
  scm = RSCM::SVN.new
  scm.svnurl = "svn://some.server/some/path/trunk"
  scm.svnpath = "trunk"

  scm.checkout("mycheckout")
  changesets = scm.changesets("mycheckout", Time.utc(2004, 11, 10, 12, 34, 22))
  changesets.each do |changeset|
    puts changeset
  end

== Future plans

=== Cross-SCM synchronisation

RSCM could be used as a tool to migrate files from one SCM to another (of a different type)
while keeping the history. -Similar to cvs2svn.

RSCM could also be used as a continuous synchronisation service between SCMs. This can be very useful
when you have to work with an SCM and you'd rather use a different one. RSCM could synchronise between
the central SCM and one that you set up on your local machine.

= Implementing support for a new SCM

We'd be happy to receive contributions for more SCMs. You can always
file a JIRA issue and hope for someone to implement it for you, or
you can do it yourself. The rest of this file should get you started.

N.B. IF YOU START IMPLEMENTING A NEW RSCM PLUGIN, PLEASE SUBMIT YOUR CODE
TO JIRA AT AN EARLY STAGE (BEFORE IT'S COMPLETE). THIS WAY IT'S EASIER
FOR EXISTING DEVELOPERS TO PROVIDE TIPS AND HELP UNDERWAY.

Let's write an RSCM implementation for the imaginary SCM called Mooky.

== Writing the API

Start by writing a test:

  test/rscm/mooky/mooky_test.rb

By including GenericSCMTests your test will automatically include the
acceptance test suite for RSCM. As you will see later, this will be of great
help when developing the Mooky class. These tests will check in a test project
and call various methods on the scm object being tested to verify that it behaves
correctly. The test project is a Java project, but you don't need Java installed.
They're just files.

Let's implement the Mooky class. Take a look at.

  lib/rscm/mooky/mooky.rb

Try running Mooky's test:

  rake test TEST=test/rscm/mooky/mooky_test.rb
  
Whoops - we got some failures! It failed because our checkout method returned 
nothing (nil). Let'see if we can get the a little further by implementing this
method.

The Mooky SCM happens to have a command line utility to perform a checkout.
From the command line a checkout with mooky would be done like this:

  cd somewhere
  mooky checkout --repo mooky://some/where/else

Running this command will print the following to standard out:

  checkout build.xml
  checkout project.xml
  checkout src/java/com/thoughtworks/damagecontrolled/Thingy.java
  checkout src/test/com/thoughtworks/damagecontrolled/ThingyTestCase.java
  
What we need to do is to execute these commands from Ruby. We also need to 
parse the output from the mooky command to determine the files that were checked out,
so that we can return an array with the file names of the checked out files (the method 
should also yield each file name as the execution proceeds).

Once your checkout command works okay, the test will get you a little further. Just keep
on going until all tests pass.

NOTE: If the SCM doesn't have a command line utility or a 3rd party Ruby API, but instead
provides libraries (perhaps in C), then you should consider writing a Ruby C extension
instead.

If the SCM has a Java interface, you can take the same approach as for StarTeam. There are
Java classes for Changesets that allow easy interaction between Ruby and Java over YAML. 
You can reuse these classes for other Java based SCMs (if there are any).

== Writing the web interface (DamageControl only)

If you're contributing a new SCM it would be nice if you took the time to implement a web interface
that can be used to embed it into DamageControl.

In trunk/damagecontrol, start by creating +app/views/project/_mooky.rhtml+. 

Create a table with 2 columns and a row for each +attr_accessor+ in the Mooky class, preferrably
with some explanatory text for the users so they know how to fill it in.

You also need a javascript section at the top
with a function called +mooky_init()+. This will be called when the page is loaded. If you don't
have plans to do anything fancy here, just leave it blank.

== Wiring it all up

Just edit +lib/rscm.rb+ and +require+ your new scm class. Now you should see it coming up
on the Source Control tab in the web interface.

= Implementation notes

* SCM classes should have a no-arg constructor and be serialisable with YAML
* SCM classes should be inexpensive to instantiate (should not access SCM in constructor)
* Instead of adding a lot of utility methods to the core objects, use visitors. This makes
  it possible to add lots of useful plugins to operate on the basic datastructures (scm/changesets)

= Building RSCM
This section is for developers who are new to ruby development and do not already know how to build and install Ruby gems.

You need to install rubygems from http://rubyforge.org/projects/rubygems
Afterwards you need to install rake and rails

  gem install rake
  gem install rails

Now change to the RSCM root directory and type

  rake

This will create a gem for RSCM. To install this gem, you have to change to the pgk directory and type

  sudo gem install rscm
  
Now you can use RSCM in other Ruby apps.
