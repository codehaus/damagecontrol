#!/usr/local/bin/ruby

# This is the main bootstrapping script for DamageControl.

# Require the files from ruby's stdlib that will be needed by damagecontrol,
# then exit if we're in rubyscript2exe packaging mode
# (gems need not be required here, they're packaged separately by lib/dist.rake)
require 'optparse'
require 'webrick'
require 'logger'
require 'fileutils'

# default environment
SHELL_DIR = defined?(RUBYSCRIPT2EXE_APPEXE) ? File.expand_path(File.dirname(RUBYSCRIPT2EXE_APPEXE)) : File.expand_path(Dir.pwd)
DC_ENV = {
  :data_dir        => SHELL_DIR,
  :database_yml    => "#{SHELL_DIR}/config/database.yml",
  :builders        => 1,
  :nowebrick       => false
}

ARGV.options do |opts|
  script_name = File.basename($0)
  
  opts.set_summary_indent('  ')
  cmd = defined?(RUBYSCRIPT2EXE_APPEXE) ? File.basename(RUBYSCRIPT2EXE_APPEXE) : "ruby #{File.basename(__FILE__)}"
  opts.banner =    "Usage: #{cmd} [options]"
  opts.define_head "Starts DamageControl"
  opts.separator   ""

  if(defined?(RUBYSCRIPT2EXE_APPEXE))
    opts.on("--eee-justextract",
            "Extract #{File.basename(RUBYSCRIPT2EXE_APPEXE)} to a single ruby script (without executing anything)") {}
  else #TAR2RUBYSCRIPT
    opts.on("--tar2rubyscript-justextract",
            "Extract #{File.basename(__FILE__)} to the current directory (without executing anything)") {}
  end

  opts.on("--data-dir=dir", String,
          "Number of build daemons to start",
          "Default: current dir = #{DC_ENV[:data_dir]}") { |dir| DC_ENV[:data_dir] = "#{SHELL_DIR}/#{dir}" }

  opts.on("--build-daemons=n", Integer,
          "Number of build daemons to start",
          "Default: #{DC_ENV[:builders]}") { |DC_ENV[:builders]| }

  opts.on("--dry-run", "Dry run. Loads the environment and exits.") do
    puts "I'm running dry..."
    ENV["RAILS_ENV"] = "production"
    require File.dirname(__FILE__) + "/../config/environment"
    puts "Done!"
    exit
  end

  opts.separator ""

  opts.on("-w", "--nowebrick",
          "Don't start the webapp",
          "Default: #{DC_ENV[:nowebrick]}") { |DC_ENV[:nowebrick]| }

  opts.parse!
end

ARGV << "--environment=#{defined?(RUBYSCRIPT2EXE_APPEXE) ? 'production' : 'development'}"
#ARGV << "--environment=production"

puts "=> DamageControl parent process running [#{Process.pid}]"
puts "=> DamageControl data directory: #{DC_ENV[:data_dir]}"
DC_ENV[:database_yml] = "#{DC_ENV[:data_dir]}/config/database.yml"
unless(File.exist?(DC_ENV[:database_yml]))
  puts "=> DamageControl database settings not found in #{DC_ENV[:database_yml]}"
  puts "=> DamageControl is creating default database settings for SQLite"
  FileUtils.mkdir_p(File.dirname(DC_ENV[:database_yml])) unless File.exist?(File.dirname(DC_ENV[:database_yml]))

  original_db_yaml = File.dirname(__FILE__) + '/../config/database.yml'
  FileUtils.cp(original_db_yaml, DC_ENV[:database_yml])
  
  dest_sqlite_db = "#{DC_ENV[:data_dir]}/db/production.db"
  unless(File.exist?(dest_sqlite_db))
    puts "=> DamageControl is copying an emtpy SQLite database to #{dest_sqlite_db}"
    FileUtils.mkdir_p(File.dirname(dest_sqlite_db)) unless File.exist?(File.dirname(dest_sqlite_db))    
    original_sqlite_db  = File.dirname(__FILE__) + '/../db/production.db'
    FileUtils.cp(original_sqlite_db, dest_sqlite_db)
  end
end

if(RUBY_PLATFORM =~ /mswin32/)
  def start_webrick
    program = File.dirname(__FILE__) + '/server'
    `ruby #{program} #{ARGV.join(' ')}`
  end

  def start_builder
    program = File.dirname(__FILE__) + '/builder'
    IO.popen("ruby #{program} #{ARGV.join(' ')}") do |io|
      io.each_line{|l| puts l}
    end
  end
else
  def start_webrick
    server_pid = fork do
      load(File.dirname(__FILE__) + '/server')
    end
    at_exit do 
      puts "Killing WEBrick [#{server_pid}]"
      Process.kill("HUP", server_pid)
    end
    Process.wait(server_pid)
  end

  def start_builder
    builder_pid = fork do
      load(File.dirname(__FILE__) + '/builder')
    end
    at_exit do 
      puts "Killing Builder [#{builder_pid}]"
      Process.kill("HUP", builder_pid)
    end
    Process.wait(builder_pid)
  end
end

threads = []

unless(DC_ENV[:nowebrick])
  threads << Thread.new do
    start_webrick
  end
end

(1..DC_ENV[:builders]).each do |i|
  threads << Thread.new do
    start_builder
  end
end

threads.each{|t| t.join}